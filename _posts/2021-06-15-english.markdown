---
layout: post
title:  "Book review: A philosophy of software design (From Ch.5 to )"
date:  2021-06-15 18:49:10 +0900 
categories: jekyll update
comments: true
tag:
  - book
  - software
---

![My helpful screenshot](/img/2021-05-18.jpg)

# Chapter 5. Information Hiding (and Leakage)

Discussing techniques for creating deep modules.

## 5.1 Information hiding

The most important technique for achieving deep module. The basic idea is that each module should encapsulated a few piece of knowledge. The knowledge is embedded in the module's implementation but does not appear in its interface.

The information hidden usually consists of detilas about how to implement some mechanism.

> 어떻게 구현햇냐에 대한것은 숨긴다

Usually - hidden information includes 'data structures' and 'algorithms', 'low level details'

Information hiding reduces complexity in two ways. - hides details. abstract view of the module's functionality. -> Reduces the congnitive load

For example, a developer doens't needs to worry about how b-tree implemented.

Second, information hiding makes it easier to evolve the system.  -> If a piece of infmration is hidden. there are no dependencies on the information outisde the module containing the information. -> 모듈화가 되어있다는 뜻

## 5.2 Information leakage

The opposite of information hiding is information leakage. This creates a dependency between the modules. -> 하나의 모듈이 바뀌었지만 여러가지 모듈이 같이 바껴야하는경우

Information leakage is one of the most important red flags in software design.

정의에 따르면 interface를 통해 정보가 공유되는것도 information leakage다. 그래서 simpler interfaces를 하는게 좋다.

if you encounter information leakage between classes, ask yourself "how can I reorganize these classes so that this particular piece of knowledge only affects a single class?" If the affected classes are relatively small and closely tied to the leaked information, it may make sense to merge them into a single class.
-> 영향받는 두 클레스가 작은 사이즈라면, 클레스를 합치는것.

or pull the information out of all of the affected classes and create a new class that encapsulates just that information. 
-> 공통된 정보를 빼내서 클래스를 따로 만드는것. 그 새로만든 인터페이스가 간단하고 encapsulate할수있어야한다.

## 5.3 Temporal decomposition(시간적 분해)

Temporal decomposition is one common cause of information leakage. In temporal decomposition, the structure of a system corresponds to the time order in which operation will occur.

> 시간순서대로 시스템 구조가 만들어져있다.

For example, reads a file, modifies the contents of the file, and then writes the file out again. With temporal decomposition, this applicaiton might be broken into three classes: read, modifiy, write.

The solution is to combine the core mechanism for reading and writing files into a single class.

> 읽기 쓰기를 하나의 클래스로 만든다.

It's easy to fall into the trap of temporal decomposition, because the order in which operations must occur is often on your mind when you code. However, most design decisions manifest htemselves at several different times over the life of the application.

> 시간순서대로 클래스를 만들지만 실제로는 어플리케이션 동작동안 여러번 나타난다.

Order usually does matter, so it will be reflected somewhere in the application. However, it shouldn't be reflected in the module structure unless that struct is consistent with information hiding.

*When designing module, focus on the knowledge that's needed to perform each task, not the order in wwhich tasks occur.*

## 5.4 Example: HTTP server
## 5.5 Example: too many classes

The most common mistake made by students was to divide their code into a large number of shallow class, which led to information leakage between the class.

The first class read the request from the network connection into a string.
The second class parsed the string.

This is good example of a temproal decomposition (First we read the request, then we parse it.)

an http request can't be read without parsing much of the message. -> 즉 그냥 읽을려고해도 메시지를 파싱해야한다.
headers must be parsed into order to compute the toal request lenght.

parsing code was duplicated in both classes. this approach also created extra complexity for caller, who had to invoke two methods in different classes, in a particular order, to receive a request.

Because the classes shared so much information, it would have been better to merge  them into a single class that handles both request reading and parsing. 

It isolates all knowledge of the request format in one class, and it also provide a simpler interface to caller.

*Information hiding can often be improved by making a class slightly larger*

## 5.6 Example: HTTP Parameter handling

## 5.8 Information hiding with a class

Information hidning can also be appplied at other levels in the system, such as within a class. Try to design the private methods hide it from the most of classes. Try to minimize the number of places where each instance variable is used. If you can reduce the number of places wwhere a variable is used, you will eliminiate dependencies within the class and reduce its complexity.

> 변수가 사용되는곳을 줄여라

## 5.9 Taking it too far

If the information is needed outside the module then you must not hide it. 

> 작동에 진짜 영향을 주는 중요한거라면 parameter로 expose하여야한다.

# Chapter 6. General-Purpose Modules are Deepper

A new module should be general-purpose or special-purpose.

a broad range of problems 를 처리해야한다고 할수도있다. 이 경우는 예상치못한 케이스를 발견할수있다. 이런경우 investment mindset으로 접근하는것이고 나중을 위해 시간을 더 쓰는것이다.

On the other hand, we know that it's hard to predict the future needs of a software system, so a general-purposoe solution might include facilities that are never actually needed. 그리고 너무 제너럴하게 하면 오늘당장 해결해야할 문제를 푸는데 적절하지않을수있다. 

if you take special-purpose approach, you can always refactor it to make it general-purpose. The special-purpose approach seems consistent with an incremental approach to software development.

## 6.1 Make classes somewhat general-purpose

Somewhat general-purpose fashion. - The module's functionality should reflect your current needs, but its interface should not. Instead, the interface should be general enough to support multiple uses.

> interface는 제너를하게 해서 나중을 대비한다.

Don't build so general-pupose that it is difficult to use for your current needs.

## 6.4 Generality leads to better information hiding



# Chapter 10. Define Erros Out Of Existence

Developers often define exceptions wwithout considering how they will be handled.

The key is to reduce the number of places where xceptions must be handled; in many cases the semantics of operations can be modified so that the normal behavior handles all situations and here is no exceptional conditions to report.

구현을 수정함으로써 일반적인 처리루틴으로 예외적인 상황을 줄일수있다.

## 10.1 Why exceptions add complexity

Exception - any uncommon condition that alter the normal flow of control in a program.

Exceptions can occur even without using a formal exception reporting mechanism, such as when a method returns a special valuue indiciating that it didn't complete its normal behavior.