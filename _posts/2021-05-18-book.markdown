---
layout: post
title:  "Book review: A philosophy of software design (WIP)"
date:  2021-05-18 18:49:10 +0900 
categories: jekyll update
comments: true
tag:
  - book
---

![My helpful screenshot](/img/2021-05-18.jpg)

# Preface

Problem decomposition: How to take a complex problem and divide it up into piece that can be solved indivisually.

Students learn best by writing code, making mistakes, and seeting how their mitakes and subsequent fixes related to the principles.

The overall goal is to reduce complexity.

# Chapter 1. Introduction (It's all about complexity)

All programming requires is a create mind and the ability to organize your thoughts. If you can visualize a system, you can probably implement it in a computer program. The limitation is our ability to understand the system.

Complexity will still increase over time, in spite of our best effrots, but simpler design allow us to build larger and more powerful systems before complexity becomes overwhelming.

Two general approaches:

* Eliminate complexity by making code simpler and more obvious.

For instance, Complexity can be reduced by eliminating special cases or using identifier in consistent fashion.

* Encapsulate the complexity = modular design

Relatively indepent of each other. so that a program can work on one module without having to understand the detail of other modules.

Waterfall model rarely works well for software. -> Scrum

## 1.1 How to use this book

The best way to use this book is in conjuction with code reviews. It's easier to see design problem in someone else's code than your code.

# Chapter 2. The Nature of Complexity

The ability to recognize complexity is a crucial design skill. It allows you to identify problem before you invest a lot of effoort in them, and it allows you oto o make good choises among alternatives. (ALTERNATIVES is the point. we don't need always the right answer.)

## 2.1 Complexity defined

*Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system.*

For example, it takes a lot of effort to implement a small improvement. it might not be clear which parts of the system must be modified to make the improvement; if it is easy to understand and modify, then it is simple.

You can also think of complexity in terms of cost and benefits.

People often use the word 'complex' to describe large systems with sophisticated feature, but if such a system is easy to work on, then, it is not complex. It is also possible for a small and unsopphisticated system to be quite complex.

If a system has a few parts that are very complicated, but those parts almost never need to be touched, then they don't have much impact on the overall complexity of the system.

If you write a piece of code and it seems simple to you, but other people think it is complex, then it is complex.

## 2.2 Symptoms of complexity

### Change amplification(확장)

A seemingly simpple change requires code modificationis in many different places. One of the goals of good esign is to reduce the amount of code that is affected by each design decisioon, so design changes don't require very many code modifications.

### Cognitive load(인지부화)

How much a developer needs to know in order to complete a task.

Sometimes an approach that requires more lines of code is actually simpler, because it reduces congnitive load.

### Unknown unknowns